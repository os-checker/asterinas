   Compiling proc-macro2 v1.0.95
   Compiling unicode-ident v1.0.18
   Compiling syn v1.0.109
   Compiling autocfg v1.4.0
   Compiling zerocopy v0.8.25
    Checking cfg-if v1.0.0
    Checking scopeguard v1.2.0
   Compiling libc v0.2.172
   Compiling getrandom v0.3.3
    Checking bitflags v1.3.2
    Checking bitflags v2.9.1
    Checking log v0.4.27
    Checking bit_field v0.10.2
   Compiling strsim v0.10.0
   Compiling fnv v1.0.7
   Compiling thiserror v2.0.12
   Compiling ident_case v1.0.1
   Compiling radium v0.7.0
   Compiling rustversion v1.0.20
    Checking tap v1.0.1
   Compiling x86 v0.52.0
    Checking uguid v2.2.1
    Checking raw-cpuid v10.7.0
   Compiling serde v1.0.219
    Checking funty v2.0.0
    Checking volatile v0.4.6
    Checking gimli v0.32.3
   Compiling either v1.15.0
    Checking acpi v5.2.0
    Checking wyz v0.5.1
    Checking smallvec v1.15.0
    Checking ostd-test v0.16.1 (/home/zjp/asterinas/ostd/libs/ostd-test)
20:01:30|RAP|INFO|: Start analysis with RAPx.
    Checking linux-boot-params v0.16.1 (/home/zjp/asterinas/ostd/libs/linux-bzimage/boot-params)
    Checking gimli v0.28.1
20:01:31|RAP|INFO|: Start analysis with RAPx.
   Compiling itertools v0.10.5
    Checking align_ext v0.1.0 (/home/zjp/asterinas/ostd/libs/align_ext)
    Checking volatile v0.6.1
20:01:31|RAP|INFO|: Start analysis with RAPx.
   Compiling equivalent v1.0.2
   Compiling hashbrown v0.15.3
   Compiling lock_api v0.4.12
20:01:32|RAP|WARN|: Intrinsic functions is incompletely retrieved.
1 fn ids are not found: [
    [
        "std::alloc::dealloc",
        "alloc::alloc::dealloc",
    ],
]
20:01:32|RAP|WARN|: Intrinsic functions is incompletely retrieved.
1 fn ids are not found: [
    [
        "std::alloc::dealloc",
        "alloc::alloc::dealloc",
    ],
]
   Compiling memoffset v0.9.1
   Compiling num-traits v0.2.19
   Compiling winnow v0.5.40
    Checking bitvec v1.0.1
   Compiling version_check v0.9.5
   Compiling json v0.12.4
   Compiling typeflags-util v0.1.0 (/home/zjp/asterinas/kernel/libs/typeflags-util)
   Compiling typenum v1.18.0
20:01:33|RAP|INFO|: Start analysis with RAPx.
20:01:34|RAP|WARN|: Intrinsic functions is incompletely retrieved.
1 fn ids are not found: [
    [
        "std::alloc::dealloc",
        "alloc::alloc::dealloc",
    ],
]
   Compiling generic-array v0.14.7
20:01:35|RAP|INFO|: Start analysis with RAPx.
   Compiling indexmap v2.9.0
20:01:35|RAP|WARN|: Intrinsic functions is incompletely retrieved.
1 fn ids are not found: [
    [
        "std::alloc::dealloc",
        "alloc::alloc::dealloc",
    ],
]
   Compiling quote v1.0.40
    Checking x86_64 v0.14.13
    Checking byteorder v1.5.0
    Checking spin v0.9.8
    Checking intrusive-collections v0.9.7
   Compiling syn v2.0.101
    Checking unwinding v0.2.8
   Compiling semver v1.0.26
    Checking lazy_static v1.5.0
    Checking stable_deref_trait v1.2.0
   Compiling paste v1.0.15
   Compiling rand_core v0.9.3
    Checking iced-x86 v1.21.0
   Compiling ahash v0.8.12
   Compiling heapless v0.8.0
    Checking allocator-api2 v0.2.21
    Checking hash32 v0.3.1
    Checking once_cell v1.21.3
    Checking cpufeatures v0.2.17
   Compiling smoltcp v0.11.0 (https://github.com/asterinas/smoltcp?tag=r_2024-11-08_f07e5b5#b10671de)
    Checking subtle v2.4.1
   Compiling macro_rules_attribute-proc_macro v0.1.3
    Checking opaque-debug v0.3.1
    Checking cipher v0.3.0
   Compiling ppv-lite86 v0.2.21
    Checking managed v0.8.0
   Compiling rustc_version v0.4.1
    Checking universal-hash v0.4.1
    Checking font8x8 v0.2.7
    Checking memchr v2.7.4
    Checking hash32 v0.2.1
    Checking takeable v0.2.2
    Checking polyval v0.5.3
    Checking never-say-never v6.6.666
    Checking foldhash v0.1.5
    Checking polonius-the-crab v0.2.1
    Checking jhash v0.1.0 (/home/zjp/asterinas/kernel/libs/jhash)
    Checking aes v0.7.5
    Checking ghash v0.4.4
    Checking ctr v0.8.0
20:01:39|RAP|INFO|: Start analysis with RAPx.
    Checking aead v0.4.3
   Compiling proc-macro-error-attr2 v2.0.0
   Compiling rand_chacha v0.9.0
    Checking id-alloc v0.1.0 (/home/zjp/asterinas/ostd/libs/id-alloc)
    Checking powerfmt v0.2.0
20:01:40|RAP|INFO|: Start analysis with RAPx.
20:01:40|RAP|WARN|: Intrinsic functions is incompletely retrieved.
1 fn ids are not found: [
    [
        "std::alloc::dealloc",
        "alloc::alloc::dealloc",
    ],
]
   Compiling heapless v0.7.17
    Checking cobs v0.2.3
    Checking rle-decode-fast v1.0.3
    Checking crc32fast v1.4.2
    Checking core2 v0.4.0
    Checking dary_heap v0.3.7
    Checking deranged v0.4.0
    Checking aes-gcm v0.9.4
   Compiling rand v0.9.2
    Checking num-conv v0.1.0
    Checking adler32 v1.2.0
    Checking macro_rules_attribute v0.1.3
    Checking bittle v0.5.7
    Checking zero v0.1.3
    Checking owo-colors v3.5.0
    Checking time-core v0.1.4
    Checking logo-ascii-art v0.1.0 (/home/zjp/asterinas/kernel/libs/logo-ascii-art)
    Checking keyable-arc v0.1.0 (/home/zjp/asterinas/kernel/libs/keyable-arc)
20:01:41|RAP|INFO|: Start analysis with RAPx.
20:01:41|RAP|INFO|: Start analysis with RAPx.
    Checking xmas-elf v0.10.0
20:01:41|RAP|WARN|: Intrinsic functions is incompletely retrieved.
1 fn ids are not found: [
    [
        "std::alloc::dealloc",
        "alloc::alloc::dealloc",
    ],
]
    Checking lru v0.12.5
   Compiling toml_datetime v0.6.9
   Compiling serde_spanned v0.6.8
    Checking time v0.3.41
   Compiling toml_edit v0.19.15
   Compiling proc-macro-error2 v2.0.1
   Compiling thiserror-impl v2.0.12
   Compiling ptr_meta_derive v0.3.0
   Compiling int-to-c-enum-derive v0.1.0 (/home/zjp/asterinas/kernel/libs/int-to-c-enum/derive)
   Compiling ostd-macros v0.16.1 (/home/zjp/asterinas/ostd/libs/ostd-macros)
   Compiling ghost v0.1.19
   Compiling serde_derive v1.0.219
   Compiling getset v0.1.5
   Compiling atomic-integer-wrapper v0.1.0 (/home/zjp/asterinas/kernel/libs/atomic-integer-wrapper)
   Compiling darling_core v0.13.4
    Checking ptr_meta v0.3.0
   Compiling toml v0.7.8
    Checking int-to-c-enum v0.1.0 (/home/zjp/asterinas/kernel/libs/int-to-c-enum)
20:01:47|RAP|INFO|: Start analysis with RAPx.
20:01:48|RAP|WARN|: Intrinsic functions is incompletely retrieved.
1 fn ids are not found: [
    [
        "std::alloc::dealloc",
        "alloc::alloc::dealloc",
    ],
]
    Checking tdx-guest v0.2.2
   Compiling ptr_meta_derive v0.2.0
   Compiling ostd-pod-derive v0.1.1 (https://github.com/asterinas/ostd-pod?rev=c4644be#c4644be4)
   Compiling ctor v0.1.25 (https://github.com/asterinas/rust-ctor#e30a5d96)
   Compiling component-macro v0.1.0 (/home/zjp/asterinas/kernel/libs/comp-sys/component-macro)
   Compiling typeflags v0.1.0 (/home/zjp/asterinas/kernel/libs/typeflags)
   Compiling aster-rights-proc v0.1.0 (/home/zjp/asterinas/kernel/libs/aster-rights-proc)
   Compiling ext-trait-proc_macros v1.0.1
   Compiling nougat-proc_macros v0.2.4
   Compiling lending-iterator-proc_macros v0.1.7
   Compiling controlled v0.1.0 (/home/zjp/asterinas/kernel/libs/comp-sys/controlled)
    Checking multiboot2-common v0.3.0
    Checking ptr_meta v0.2.0
    Checking ext-trait v1.0.1
    Checking ostd-pod v0.1.1 (https://github.com/asterinas/ostd-pod?rev=c4644be#c4644be4)
    Checking uefi-raw v0.8.0
    Checking inventory v0.3.3 (https://github.com/asterinas/inventory?rev=9dce587#9dce5871)
    Checking extension-traits v1.0.1
    Checking component v0.1.0 (/home/zjp/asterinas/kernel/libs/comp-sys/component)
20:01:54|RAP|INFO|: Start analysis with RAPx.
   Compiling darling_macro v0.13.4
    Checking nougat v0.2.4
    Checking lending-iterator v0.1.7
   Compiling darling v0.13.4
Over visited: DefId(0:44 ~ component[3437]::match_and_call)
   Compiling inherit-methods-macro v0.1.0 (https://github.com/asterinas/inherit-methods-macro?rev=98f7e3e#98f7e3eb)
    Checking cpio-decoder v0.1.0 (/home/zjp/asterinas/kernel/libs/cpio-decoder)
20:01:55|RAP|INFO|: Start analysis with RAPx.
    Checking aster-rights v0.1.0 (/home/zjp/asterinas/kernel/libs/aster-rights)
20:01:55|RAP|INFO|: Start analysis with RAPx.
    Checking multiboot2 v0.24.0
20:01:56|RAP|WARN|: Intrinsic functions is incompletely retrieved.
1 fn ids are not found: [
    [
        "std::alloc::dealloc",
        "alloc::alloc::dealloc",
    ],
]
    Checking ostd v0.16.1 (/home/zjp/asterinas/ostd)
20:01:58|RAP|INFO|: Start analysis with RAPx.
20:01:59|RAP|WARN|: Dangling pointer detected in function "next"
warning: Dangling pointer detected.
  --> kernel/libs/cpio-decoder/src/lib.rs:76:1
   |
76 | / fn next(&mut self) -> Option<Self::Item<'_>> {
77 | |         // Stop to iterate entries if encounters an error.
78 | |         if self.is_error {
79 | |             return None;
80 | |         }
81 | |
82 | |         let entry_result = CpioEntry::new(&mut self.reader);
83 | |         match &entry_result {
84 | |             Ok(entry) => {
85 | |                 // A correct CPIO buffer must end with a trailer.
86 | |                 if entry.is_trailer() {
87 | |                     return None;
88 | |                 }
89 | |             }
90 | |             Err(_) => {
91 | |                 self.is_error = true;
92 | |             }
93 | |         }
94 | |         Some(entry_result)
95 | |     }
   | |_____- 
 Dangling pointer (confidence 99%): Location in file kernel/libs/cpio-decoder/src/lib.rs line 76.
    | MIR detail: Value _18446744073709551615 and _1 are alias.
    | MIR detail: _18446744073709551615 is dropped at BB18446744073709551615; _1 became dangling.
   |
Over visited: DefId(0:52 ~ aster_rights[070b]::{impl#10}::fmt)
    Checking hashbrown v0.14.5
    Checking postcard v1.1.1
    Checking libflate_lz77 v2.1.0
    Checking libflate v2.1.0
20:03:04|RAP|WARN|: Memory Leak detected in function into_raw
warning: Memory Leak detected.
   --> ostd/src/sync/rcu/non_null/mod.rs:116:19
    |
115 | fn into_raw(self) -> NonNull<Self::Target> {
116 |         let ptr = Box::into_raw(self);
    |                   ------------------- Memory Leak Candidates.
117 |
118 |         // SAFETY: The pointer representing a `Box` can never be NULL.
119 |         unsafe { NonNull::new_unchecked(ptr) }
120 |     }
    |
20:03:07|RAP|WARN|: Memory Leak detected in function init
warning: Memory Leak detected.
  --> ostd/src/task/scheduler/fifo_scheduler.rs:17:21
   |
15 | pub fn init() {
16 |     let fifo_scheduler = Box::new(FifoScheduler::default());
17 |     let scheduler = Box::<FifoScheduler<Task>>::leak(fifo_scheduler);
   |                     ------------------------------------------------ Memory Leak Candidates.
18 |     inject_scheduler(scheduler);
19 | }
   |
Over visited: DefId(0:5965 ~ ostd[ff8b]::arch::cpu::context::{impl#53}::fmt)
Over visited: DefId(0:6188 ~ ostd[ff8b]::arch::cpu::extension::{impl#8}::fmt)
Over visited: DefId(0:6514 ~ ostd[ff8b]::arch::iommu::dma_remapping::second_stage::{impl#19}::fmt)
Over visited: DefId(0:6700 ~ ostd[ff8b]::arch::iommu::fault::{impl#14}::fmt)
Over visited: DefId(0:6882 ~ ostd[ff8b]::arch::iommu::interrupt_remapping::table::{impl#20}::fmt)
Over visited: DefId(0:6992 ~ ostd[ff8b]::arch::iommu::registers::capability::{impl#10}::fmt)
Over visited: DefId(0:7142 ~ ostd[ff8b]::arch::iommu::registers::capability::{impl#35}::fmt)
Over visited: DefId(0:7237 ~ ostd[ff8b]::arch::iommu::registers::capability::{impl#60}::fmt)
Over visited: DefId(0:7327 ~ ostd[ff8b]::arch::iommu::registers::command::{impl#8}::fmt)
Over visited: DefId(0:7442 ~ ostd[ff8b]::arch::iommu::registers::extended_cap::{impl#10}::fmt)
Over visited: DefId(0:7676 ~ ostd[ff8b]::arch::iommu::registers::status::{impl#8}::fmt)
Over visited: DefId(0:791 ~ ostd[ff8b]::arch::iommu::registers::{impl#1}::new)
Over visited: DefId(0:8128 ~ ostd[ff8b]::arch::mm::{impl#17}::fmt)
Over visited: DefId(0:8283 ~ ostd[ff8b]::arch::serial::{impl#8}::fmt)
Over visited: DefId(0:9140 ~ ostd[ff8b]::mm::page_prop::{impl#21}::fmt)
Over visited: DefId(0:9265 ~ ostd[ff8b]::mm::page_prop::{impl#46}::fmt)
20:03:27|RAP|WARN|: Double free detected in function wait_until
warning: Double free detected.
  --> ostd/src/sync/wait.rs:69:1
   |
69 | / pub fn wait_until<F, R>(&self, mut cond: F) -> R
70 | |     where
71 | |         F: FnMut() -> Option<R>,
72 | |     {
73 | |         if let Some(res) = cond() {
74 | |             return res;
75 | |         }
76 | |
77 | |         let (waiter, _) = Waiter::new_pair();
78 | |         let cond = || {
79 | |             self.enqueue(waiter.waker());
80 | |             cond()
81 | |         };
82 | |         waiter
83 | |             .wait_until_or_cancelled(cond, || Ok::<(), ()>(()))
84 | |             .unwrap()
85 | |     }
   | |_____- 
 Double free (confidence 99%): Location in file ostd/src/sync/wait.rs line 69.
    | MIR detail: Value _10 and _2 are alias.
    | MIR detail: _10 is dropped at BB5; _2 is dropped at BB6.
   |
20:03:27|RAP|WARN|: Dangling pointer detected in function "wait_until"
warning: Dangling pointer detected.
  --> ostd/src/sync/wait.rs:69:1
   |
69 | / pub fn wait_until<F, R>(&self, mut cond: F) -> R
70 | |     where
71 | |         F: FnMut() -> Option<R>,
72 | |     {
73 | |         if let Some(res) = cond() {
74 | |             return res;
75 | |         }
76 | |
77 | |         let (waiter, _) = Waiter::new_pair();
78 | |         let cond = || {
79 | |             self.enqueue(waiter.waker());
80 | |             cond()
81 | |         };
82 | |         waiter
83 | |             .wait_until_or_cancelled(cond, || Ok::<(), ()>(()))
84 | |             .unwrap()
85 | |     }
   | |_____- 
 Dangling pointer (confidence 99%): Location in file ostd/src/sync/wait.rs line 69.
    | MIR detail: Value _10 and _1 are alias.
    | MIR detail: _10 is dropped at BB5; _1 became dangling.
   |
    Checking osdk-heap-allocator v0.16.1 (/home/zjp/asterinas/osdk/deps/heap-allocator)
    Checking aster-console v0.1.0 (/home/zjp/asterinas/kernel/comps/console)
    Checking aster-input v0.1.0 (/home/zjp/asterinas/kernel/comps/input)
    Checking aster-pci v0.1.0 (/home/zjp/asterinas/kernel/comps/pci)
    Checking aster-cmdline v0.1.0 (/home/zjp/asterinas/kernel/comps/cmdline)
    Checking xarray v0.1.0 (/home/zjp/asterinas/kernel/libs/xarray)
    Checking osdk-frame-allocator v0.16.1 (/home/zjp/asterinas/osdk/deps/frame-allocator)
20:03:28|RAP|INFO|: Start analysis with RAPx.
20:03:28|RAP|INFO|: Start analysis with RAPx.
20:03:28|RAP|INFO|: Start analysis with RAPx.
20:03:28|RAP|INFO|: Start analysis with RAPx.
20:03:28|RAP|INFO|: Start analysis with RAPx.
20:03:28|RAP|INFO|: Start analysis with RAPx.
20:03:28|RAP|INFO|: Start analysis with RAPx.
    Checking aster-logger v0.1.0 (/home/zjp/asterinas/kernel/comps/logger)
20:03:32|RAP|INFO|: Start analysis with RAPx.
    Checking aster-util v0.1.0 (/home/zjp/asterinas/kernel/libs/aster-util)
20:03:35|RAP|INFO|: Start analysis with RAPx.
Over visited: DefId(0:404 ~ aster_pci[e7cd]::cfg_space::{impl#11}::fmt)
Over visited: DefId(0:534 ~ aster_pci[e7cd]::cfg_space::{impl#36}::fmt)
Over visited: DefId(0:230 ~ aster_input[8fae]::event_type_codes::{impl#14}::fmt)
20:03:41|RAP|WARN|: Double free detected in function unregister_device
warning: Double free detected.
   --> kernel/comps/input/src/input_core.rs:153:1
    |
153 | / pub(crate) fn unregister_device(
154 | |         &mut self,
155 | |         device: &Arc<dyn InputDevice>,
156 | |     ) -> Option<Arc<dyn InputDevice>> {
157 | |         // Find the device and remove it.
158 | |         let pos = self
159 | |             .devices
160 | |             .iter()
161 | |             .position(|registry| Arc::ptr_eq(&registry.device, device))?;
162 | |         let device_registry = self.devices.swap_remove(pos);
163 | |
164 | |         // Take all handlers connected to this device and clear the list.
165 | |         let mut handlers = device_registry.handlers.write();
166 | |         let bound_handlers = core::mem::take(&mut *handlers);
167 | |         drop(handlers);
168 | |
169 | |         // Disconnect handler classes that were connected.
170 | |         for bound_handler in bound_handlers.into_iter() {
171 | |             bound_handler
172 | |                 .handler_class
173 | |                 .disconnect(&device_registry.device);
174 | |         }
175 | |
176 | |         log::info!("Input: unregistered device {}", device.name());
177 | |         Some(device_registry.device)
178 | |     }
    | |_____- 
 Double free (confidence 99%): Location in file kernel/comps/input/src/input_core.rs line 153.
    | MIR detail: Value _31 and _18 are alias.
    | MIR detail: _31 is dropped at BB13; _18 is dropped at BB39.
    |
20:03:41|RAP|WARN|: Use-after-free detected in function "unregister_device"
warning: Use-after-free detected.
   --> kernel/comps/input/src/input_core.rs:170:30
    |
153 | pub(crate) fn unregister_device(
154 |         &mut self,
155 |         device: &Arc<dyn InputDevice>,
156 |     ) -> Option<Arc<dyn InputDevice>> {
157 |         // Find the device and remove it.
158 |         let pos = self
159 |             .devices
160 |             .iter()
161 |             .position(|registry| Arc::ptr_eq(&registry.device, device))?;
162 |         let device_registry = self.devices.swap_remove(pos);
163 |
164 |         // Take all handlers connected to this device and clear the list.
165 |         let mut handlers = device_registry.handlers.write();
166 |         let bound_handlers = core::mem::take(&mut *handlers);
167 |         drop(handlers);
168 |
169 |         // Disconnect handler classes that were connected.
170 |         for bound_handler in bound_handlers.into_iter() {
    |                              -------------------------- 
 Use-after-free (confidence 99%): Location in file kernel/comps/input/src/input_core.rs line 170.
    | MIR detail: Value _31 and _35 are alias.
    | MIR detail: _31 is dropped at BB13; _35 is used at BB14.
171 |             bound_handler
172 |                 .handler_class
173 |                 .disconnect(&device_registry.device);
174 |         }
175 |
176 |         log::info!("Input: unregistered device {}", device.name());
177 |         Some(device_registry.device)
178 |     }
    |
warning: Use-after-free detected.
   --> kernel/comps/input/src/input_core.rs:170:30
    |
153 | pub(crate) fn unregister_device(
154 |         &mut self,
155 |         device: &Arc<dyn InputDevice>,
156 |     ) -> Option<Arc<dyn InputDevice>> {
157 |         // Find the device and remove it.
158 |         let pos = self
159 |             .devices
160 |             .iter()
161 |             .position(|registry| Arc::ptr_eq(&registry.device, device))?;
162 |         let device_registry = self.devices.swap_remove(pos);
163 |
164 |         // Take all handlers connected to this device and clear the list.
165 |         let mut handlers = device_registry.handlers.write();
166 |         let bound_handlers = core::mem::take(&mut *handlers);
167 |         drop(handlers);
168 |
169 |         // Disconnect handler classes that were connected.
170 |         for bound_handler in bound_handlers.into_iter() {
    |                              -------------- 
 Use-after-free (confidence 99%): Location in file kernel/comps/input/src/input_core.rs line 170.
    | MIR detail: Value _31 and _25 are alias.
    | MIR detail: _31 is dropped at BB13; _25 is used at BB14.
171 |             bound_handler
172 |                 .handler_class
173 |                 .disconnect(&device_registry.device);
174 |         }
175 |
176 |         log::info!("Input: unregistered device {}", device.name());
177 |         Some(device_registry.device)
178 |     }
    |
    Checking aster-i8042 v0.1.0 (/home/zjp/asterinas/kernel/comps/i8042)
    Checking aster-framebuffer v0.1.0 (/home/zjp/asterinas/kernel/comps/framebuffer)
20:03:41|RAP|INFO|: Start analysis with RAPx.
20:03:41|RAP|INFO|: Start analysis with RAPx.
    Checking aster-softirq v0.1.0 (/home/zjp/asterinas/kernel/comps/softirq)
    Checking device-id v0.1.0 (/home/zjp/asterinas/kernel/libs/device-id)
    Checking aster-systree v0.1.0 (/home/zjp/asterinas/kernel/comps/systree)
    Checking aster-time v0.1.0 (/home/zjp/asterinas/kernel/comps/time)
20:03:45|RAP|INFO|: Start analysis with RAPx.
20:03:45|RAP|INFO|: Start analysis with RAPx.
20:03:45|RAP|INFO|: Start analysis with RAPx.
20:03:45|RAP|INFO|: Start analysis with RAPx.
    Checking aster-block v0.1.0 (/home/zjp/asterinas/kernel/comps/block)
20:03:46|RAP|INFO|: Start analysis with RAPx.
    Checking aster-bigtcp v0.1.0 (/home/zjp/asterinas/kernel/libs/aster-bigtcp)
20:03:47|RAP|INFO|: Start analysis with RAPx.
Over visited: DefId(0:22 ~ aster_i8042[a60e]::controller::init)
Over visited: DefId(0:248 ~ aster_i8042[a60e]::mouse::{impl#5}::parse_packet)
    Checking aster-mlsdisk v0.1.0 (/home/zjp/asterinas/kernel/comps/mlsdisk)
20:03:55|RAP|INFO|: Start analysis with RAPx.
20:03:56|RAP|WARN|: Dangling pointer detected in function "read_rtc"
warning: Dangling pointer detected.
   --> kernel/comps/time/src/rtc/cmos.rs:179:1
    |
179 | / pub(self) fn read_rtc(rtc: &RtcCmos) -> Self {
180 | |         let mut access = rtc.access.lock();
181 | |
182 | |         let mut now = Self::from_rtc_raw(&mut access);
183 | |         // Retry if the new value differs from the old one. An RTC update may occur in the
184 | |         // meantime, which would result in an invalid value.
185 | |         while let new = Self::from_rtc_raw(&mut access) && now != new {
186 | |             now = new;
187 | |         }
188 | |
189 | |         drop(access);
190 | |
191 | |         if !rtc.status_b.contains(StatusB::DM_BINARY) {
192 | |             now.convert_bcd_to_binary();
193 | |         }
194 | |         if !rtc.status_b.contains(StatusB::CM_24HOUR) {
195 | |             now.convert_12_hour_to_24_hour();
196 | |         }
197 | |         now.modify_year();
198 | |
199 | |         now
200 | |     }
    | |_____- 
 Dangling pointer (confidence 99%): Location in file kernel/comps/time/src/rtc/cmos.rs line 179.
    | MIR detail: Value _18446744073709551615 and _1 are alias.
    | MIR detail: _18446744073709551615 is dropped at BB18446744073709551615; _1 became dangling.
    |
Over visited: DefId(0:1259 ~ aster_bigtcp[0147]::iface::common::{impl#23}::fmt)
Over visited: DefId(0:1480 ~ aster_bigtcp[0147]::socket::event::{impl#9}::fmt)
    Checking aster-network v0.1.0 (/home/zjp/asterinas/kernel/comps/network)
20:04:08|RAP|INFO|: Start analysis with RAPx.
    Checking aster-virtio v0.1.0 (/home/zjp/asterinas/kernel/comps/virtio)
20:04:26|RAP|INFO|: Start analysis with RAPx.
Over visited: DefId(0:1311 ~ aster_virtio[0497]::device::block::{impl#11}::fmt)
Over visited: DefId(0:1563 ~ aster_virtio[0497]::device::console::config::{impl#10}::fmt)
Over visited: DefId(0:1669 ~ aster_virtio[0497]::device::input::device::{impl#14}::fmt)
20:05:32|RAP|WARN|: Use-after-free detected in function "init"
warning: Use-after-free detected.
   --> kernel/comps/virtio/src/device/input/device.rs:170:9
    |
 92 | pub fn init(mut transport: Box<dyn VirtioTransport>) -> Result<(), VirtioDeviceError> {
 93 |         let mut event_queue = VirtQueue::new(QUEUE_EVENT, QUEUE_SIZE, transport.as_mut())
 94 |             .expect("create event virtqueue failed");
 95 |         let status_queue = VirtQueue::new(QUEUE_STATUS, QUEUE_SIZE, transport.as_mut())
 96 |             .expect("create status virtqueue failed");
 97 |
 98 |         let event_table = EventTable::new(QUEUE_SIZE as usize);
 99 |         for i in 0..event_table.num_events() {
100 |             let event_buf = event_table.get(i);
101 |             let token = event_queue.add_dma_buf(&[], &[&event_buf]);
102 |             match token {
103 |                 Ok(value) => {
104 |                     assert_eq!(value, i as u16);
105 |                 }
106 |                 Err(_) => {
107 |                     return Err(VirtioDeviceError::QueueUnknownError);
108 |                 }
109 |             }
110 |         }
111 |
112 |         let device = {
113 |             let mut device = Self {
114 |                 config: VirtioInputConfig::new(transport.as_mut()),
115 |                 event_queue: SpinLock::new(event_queue),
116 |                 status_queue,
117 |                 event_table,
118 |                 transport: SpinLock::new(transport),
119 |                 // Default name, will be updated with actual device name from config.
120 |                 device_name: "virtio_input".to_string(),
121 |                 // Physical path for virtio devices.
122 |                 device_phys: "virtio/input0".to_string(),
123 |                 // Unique identifier (empty for virtio devices).
124 |                 device_uniq: "".to_string(),
125 |                 // Device ID with virtio-specific values.
126 |                 // BUS_VIRTUAL (0x06): Virtual bus type
127 |                 // vendor (0x0001): Generic vendor ID for standard keyboards
128 |                 // product (0x0001): Generic product ID for standard keyboards
129 |                 // version (0x0001): Version 1.0
130 |                 device_id: InputId::new(InputId::BUS_VIRTUAL, 0x0001, 0x0001, 0x0001),
131 |                 capability: InputCapability::new(),
132 |             };
133 |
134 |             // Query and update device name from config.
135 |             let name = device.query_config_id_name();
136 |             info!("Virtio input device name: {}", name);
137 |             device.device_name = name;
138 |
139 |             // Query and set device capabilities.
140 |             device.query_and_set_capabilities();
141 |
142 |             Arc::new(device)
143 |         };
144 |
145 |         let input_prop = device.query_config_prop_bits();
146 |         if let Some(prop) = input_prop {
147 |             debug!("input device prop: {:?}", prop);
148 |         } else {
149 |             debug!("input device has no properties or the properties is not defined");
150 |         }
151 |
152 |         let mut transport = device.transport.disable_irq().lock();
153 |         fn config_space_change(_: &TrapFrame) {
154 |             debug!("input device config space change");
155 |         }
156 |         transport
157 |             .register_cfg_callback(Box::new(config_space_change))
158 |             .unwrap();
159 |         transport.finish_init();
160 |         drop(transport);
161 |
162 |         // Register with the input subsystem.
163 |         let registered_device = aster_input::register_device(device.clone());
164 |
165 |         let mut transport = device.transport.disable_irq().lock();
166 |         let handle_input = {
167 |             let device = device.clone();
168 |             move |_: &TrapFrame| device.handle_irq(&registered_device)
169 |         };
170 |         transport
    |         --------- 
 Use-after-free (confidence 99%): Location in file kernel/comps/virtio/src/device/input/device.rs line 170.
    | MIR detail: Value _216 and _221 are alias.
    | MIR detail: _216 is dropped at BB85; _221 is used at BB92.
171 |             .register_queue_callback(QUEUE_EVENT, Box::new(handle_input), false)
172 |             .unwrap();
173 |         drop(transport);
174 |
175 |         Ok(())
176 |     }
    |
warning: Use-after-free detected.
   --> kernel/comps/virtio/src/device/input/device.rs:170:9
    |
 92 |   pub fn init(mut transport: Box<dyn VirtioTransport>) -> Result<(), VirtioDeviceError> {
 93 |           let mut event_queue = VirtQueue::new(QUEUE_EVENT, QUEUE_SIZE, transport.as_mut())
 94 |               .expect("create event virtqueue failed");
 95 |           let status_queue = VirtQueue::new(QUEUE_STATUS, QUEUE_SIZE, transport.as_mut())
 96 |               .expect("create status virtqueue failed");
 97 |
 98 |           let event_table = EventTable::new(QUEUE_SIZE as usize);
 99 |           for i in 0..event_table.num_events() {
100 |               let event_buf = event_table.get(i);
101 |               let token = event_queue.add_dma_buf(&[], &[&event_buf]);
102 |               match token {
103 |                   Ok(value) => {
104 |                       assert_eq!(value, i as u16);
105 |                   }
106 |                   Err(_) => {
107 |                       return Err(VirtioDeviceError::QueueUnknownError);
108 |                   }
109 |               }
110 |           }
111 |
112 |           let device = {
113 |               let mut device = Self {
114 |                   config: VirtioInputConfig::new(transport.as_mut()),
115 |                   event_queue: SpinLock::new(event_queue),
116 |                   status_queue,
117 |                   event_table,
118 |                   transport: SpinLock::new(transport),
119 |                   // Default name, will be updated with actual device name from config.
120 |                   device_name: "virtio_input".to_string(),
121 |                   // Physical path for virtio devices.
122 |                   device_phys: "virtio/input0".to_string(),
123 |                   // Unique identifier (empty for virtio devices).
124 |                   device_uniq: "".to_string(),
125 |                   // Device ID with virtio-specific values.
126 |                   // BUS_VIRTUAL (0x06): Virtual bus type
127 |                   // vendor (0x0001): Generic vendor ID for standard keyboards
128 |                   // product (0x0001): Generic product ID for standard keyboards
129 |                   // version (0x0001): Version 1.0
130 |                   device_id: InputId::new(InputId::BUS_VIRTUAL, 0x0001, 0x0001, 0x0001),
131 |                   capability: InputCapability::new(),
132 |               };
133 |
134 |               // Query and update device name from config.
135 |               let name = device.query_config_id_name();
136 |               info!("Virtio input device name: {}", name);
137 |               device.device_name = name;
138 |
139 |               // Query and set device capabilities.
140 |               device.query_and_set_capabilities();
141 |
142 |               Arc::new(device)
143 |           };
144 |
145 |           let input_prop = device.query_config_prop_bits();
146 |           if let Some(prop) = input_prop {
147 |               debug!("input device prop: {:?}", prop);
148 |           } else {
149 |               debug!("input device has no properties or the properties is not defined");
150 |           }
151 |
152 |           let mut transport = device.transport.disable_irq().lock();
153 |           fn config_space_change(_: &TrapFrame) {
154 |               debug!("input device config space change");
155 |           }
156 |           transport
157 |               .register_cfg_callback(Box::new(config_space_change))
158 |               .unwrap();
159 |           transport.finish_init();
160 |           drop(transport);
161 |
162 |           // Register with the input subsystem.
163 |           let registered_device = aster_input::register_device(device.clone());
164 |
165 |           let mut transport = device.transport.disable_irq().lock();
166 |           let handle_input = {
167 |               let device = device.clone();
168 |               move |_: &TrapFrame| device.handle_irq(&registered_device)
169 |           };
170 | /         transport
171 | |             .register_queue_callback(QUEUE_EVENT, Box::new(handle_input), false)
    | |________________________________________________________________________________- 
 Use-after-free (confidence 99%): Location in file kernel/comps/virtio/src/device/input/device.rs line 170.
    | MIR detail: Value _216 and _234 are alias.
    | MIR detail: _216 is dropped at BB85; _234 is used at BB92.
172 |               .unwrap();
173 |           drop(transport);
174 |
175 |           Ok(())
176 |       }
    |
warning: Use-after-free detected.
   --> kernel/comps/virtio/src/device/input/device.rs:173:9
    |
 92 | pub fn init(mut transport: Box<dyn VirtioTransport>) -> Result<(), VirtioDeviceError> {
 93 |         let mut event_queue = VirtQueue::new(QUEUE_EVENT, QUEUE_SIZE, transport.as_mut())
 94 |             .expect("create event virtqueue failed");
 95 |         let status_queue = VirtQueue::new(QUEUE_STATUS, QUEUE_SIZE, transport.as_mut())
 96 |             .expect("create status virtqueue failed");
 97 |
 98 |         let event_table = EventTable::new(QUEUE_SIZE as usize);
 99 |         for i in 0..event_table.num_events() {
100 |             let event_buf = event_table.get(i);
101 |             let token = event_queue.add_dma_buf(&[], &[&event_buf]);
102 |             match token {
103 |                 Ok(value) => {
104 |                     assert_eq!(value, i as u16);
105 |                 }
106 |                 Err(_) => {
107 |                     return Err(VirtioDeviceError::QueueUnknownError);
108 |                 }
109 |             }
110 |         }
111 |
112 |         let device = {
113 |             let mut device = Self {
114 |                 config: VirtioInputConfig::new(transport.as_mut()),
115 |                 event_queue: SpinLock::new(event_queue),
116 |                 status_queue,
117 |                 event_table,
118 |                 transport: SpinLock::new(transport),
119 |                 // Default name, will be updated with actual device name from config.
120 |                 device_name: "virtio_input".to_string(),
121 |                 // Physical path for virtio devices.
122 |                 device_phys: "virtio/input0".to_string(),
123 |                 // Unique identifier (empty for virtio devices).
124 |                 device_uniq: "".to_string(),
125 |                 // Device ID with virtio-specific values.
126 |                 // BUS_VIRTUAL (0x06): Virtual bus type
127 |                 // vendor (0x0001): Generic vendor ID for standard keyboards
128 |                 // product (0x0001): Generic product ID for standard keyboards
129 |                 // version (0x0001): Version 1.0
130 |                 device_id: InputId::new(InputId::BUS_VIRTUAL, 0x0001, 0x0001, 0x0001),
131 |                 capability: InputCapability::new(),
132 |             };
133 |
134 |             // Query and update device name from config.
135 |             let name = device.query_config_id_name();
136 |             info!("Virtio input device name: {}", name);
137 |             device.device_name = name;
138 |
139 |             // Query and set device capabilities.
140 |             device.query_and_set_capabilities();
141 |
142 |             Arc::new(device)
143 |         };
144 |
145 |         let input_prop = device.query_config_prop_bits();
146 |         if let Some(prop) = input_prop {
147 |             debug!("input device prop: {:?}", prop);
148 |         } else {
149 |             debug!("input device has no properties or the properties is not defined");
150 |         }
151 |
152 |         let mut transport = device.transport.disable_irq().lock();
153 |         fn config_space_change(_: &TrapFrame) {
154 |             debug!("input device config space change");
155 |         }
156 |         transport
157 |             .register_cfg_callback(Box::new(config_space_change))
158 |             .unwrap();
159 |         transport.finish_init();
160 |         drop(transport);
161 |
162 |         // Register with the input subsystem.
163 |         let registered_device = aster_input::register_device(device.clone());
164 |
165 |         let mut transport = device.transport.disable_irq().lock();
166 |         let handle_input = {
167 |             let device = device.clone();
168 |             move |_: &TrapFrame| device.handle_irq(&registered_device)
169 |         };
170 |         transport
171 |             .register_queue_callback(QUEUE_EVENT, Box::new(handle_input), false)
172 |             .unwrap();
173 |         drop(transport);
    |         --------------- 
 Use-after-free (confidence 99%): Location in file kernel/comps/virtio/src/device/input/device.rs line 173.
    | MIR detail: Value _216 and _239 are alias.
    | MIR detail: _216 is dropped at BB85; _239 is used at BB96.
174 |
175 |         Ok(())
176 |     }
    |
warning: Use-after-free detected.
   --> kernel/comps/virtio/src/device/input/device.rs:165:29
    |
 92 | pub fn init(mut transport: Box<dyn VirtioTransport>) -> Result<(), VirtioDeviceError> {
 93 |         let mut event_queue = VirtQueue::new(QUEUE_EVENT, QUEUE_SIZE, transport.as_mut())
 94 |             .expect("create event virtqueue failed");
 95 |         let status_queue = VirtQueue::new(QUEUE_STATUS, QUEUE_SIZE, transport.as_mut())
 96 |             .expect("create status virtqueue failed");
 97 |
 98 |         let event_table = EventTable::new(QUEUE_SIZE as usize);
 99 |         for i in 0..event_table.num_events() {
100 |             let event_buf = event_table.get(i);
101 |             let token = event_queue.add_dma_buf(&[], &[&event_buf]);
102 |             match token {
103 |                 Ok(value) => {
104 |                     assert_eq!(value, i as u16);
105 |                 }
106 |                 Err(_) => {
107 |                     return Err(VirtioDeviceError::QueueUnknownError);
108 |                 }
109 |             }
110 |         }
111 |
112 |         let device = {
113 |             let mut device = Self {
114 |                 config: VirtioInputConfig::new(transport.as_mut()),
115 |                 event_queue: SpinLock::new(event_queue),
116 |                 status_queue,
117 |                 event_table,
118 |                 transport: SpinLock::new(transport),
119 |                 // Default name, will be updated with actual device name from config.
120 |                 device_name: "virtio_input".to_string(),
121 |                 // Physical path for virtio devices.
122 |                 device_phys: "virtio/input0".to_string(),
123 |                 // Unique identifier (empty for virtio devices).
124 |                 device_uniq: "".to_string(),
125 |                 // Device ID with virtio-specific values.
126 |                 // BUS_VIRTUAL (0x06): Virtual bus type
127 |                 // vendor (0x0001): Generic vendor ID for standard keyboards
128 |                 // product (0x0001): Generic product ID for standard keyboards
129 |                 // version (0x0001): Version 1.0
130 |                 device_id: InputId::new(InputId::BUS_VIRTUAL, 0x0001, 0x0001, 0x0001),
131 |                 capability: InputCapability::new(),
132 |             };
133 |
134 |             // Query and update device name from config.
135 |             let name = device.query_config_id_name();
136 |             info!("Virtio input device name: {}", name);
137 |             device.device_name = name;
138 |
139 |             // Query and set device capabilities.
140 |             device.query_and_set_capabilities();
141 |
142 |             Arc::new(device)
143 |         };
144 |
145 |         let input_prop = device.query_config_prop_bits();
146 |         if let Some(prop) = input_prop {
147 |             debug!("input device prop: {:?}", prop);
148 |         } else {
149 |             debug!("input device has no properties or the properties is not defined");
150 |         }
151 |
152 |         let mut transport = device.transport.disable_irq().lock();
153 |         fn config_space_change(_: &TrapFrame) {
154 |             debug!("input device config space change");
155 |         }
156 |         transport
157 |             .register_cfg_callback(Box::new(config_space_change))
158 |             .unwrap();
159 |         transport.finish_init();
160 |         drop(transport);
161 |
162 |         // Register with the input subsystem.
163 |         let registered_device = aster_input::register_device(device.clone());
164 |
165 |         let mut transport = device.transport.disable_irq().lock();
    |                             ------------------------------ 
 Use-after-free (confidence 99%): Location in file kernel/comps/virtio/src/device/input/device.rs line 165.
    | MIR detail: Value _216 and _224 are alias.
    | MIR detail: _216 is dropped at BB85; _224 is used at BB89.
166 |         let handle_input = {
167 |             let device = device.clone();
168 |             move |_: &TrapFrame| device.handle_irq(&registered_device)
169 |         };
170 |         transport
171 |             .register_queue_callback(QUEUE_EVENT, Box::new(handle_input), false)
172 |             .unwrap();
173 |         drop(transport);
174 |
175 |         Ok(())
176 |     }
    |
warning: Use-after-free detected.
   --> kernel/comps/virtio/src/device/input/device.rs:165:29
    |
 92 | pub fn init(mut transport: Box<dyn VirtioTransport>) -> Result<(), VirtioDeviceError> {
 93 |         let mut event_queue = VirtQueue::new(QUEUE_EVENT, QUEUE_SIZE, transport.as_mut())
 94 |             .expect("create event virtqueue failed");
 95 |         let status_queue = VirtQueue::new(QUEUE_STATUS, QUEUE_SIZE, transport.as_mut())
 96 |             .expect("create status virtqueue failed");
 97 |
 98 |         let event_table = EventTable::new(QUEUE_SIZE as usize);
 99 |         for i in 0..event_table.num_events() {
100 |             let event_buf = event_table.get(i);
101 |             let token = event_queue.add_dma_buf(&[], &[&event_buf]);
102 |             match token {
103 |                 Ok(value) => {
104 |                     assert_eq!(value, i as u16);
105 |                 }
106 |                 Err(_) => {
107 |                     return Err(VirtioDeviceError::QueueUnknownError);
108 |                 }
109 |             }
110 |         }
111 |
112 |         let device = {
113 |             let mut device = Self {
114 |                 config: VirtioInputConfig::new(transport.as_mut()),
115 |                 event_queue: SpinLock::new(event_queue),
116 |                 status_queue,
117 |                 event_table,
118 |                 transport: SpinLock::new(transport),
119 |                 // Default name, will be updated with actual device name from config.
120 |                 device_name: "virtio_input".to_string(),
121 |                 // Physical path for virtio devices.
122 |                 device_phys: "virtio/input0".to_string(),
123 |                 // Unique identifier (empty for virtio devices).
124 |                 device_uniq: "".to_string(),
125 |                 // Device ID with virtio-specific values.
126 |                 // BUS_VIRTUAL (0x06): Virtual bus type
127 |                 // vendor (0x0001): Generic vendor ID for standard keyboards
128 |                 // product (0x0001): Generic product ID for standard keyboards
129 |                 // version (0x0001): Version 1.0
130 |                 device_id: InputId::new(InputId::BUS_VIRTUAL, 0x0001, 0x0001, 0x0001),
131 |                 capability: InputCapability::new(),
132 |             };
133 |
134 |             // Query and update device name from config.
135 |             let name = device.query_config_id_name();
136 |             info!("Virtio input device name: {}", name);
137 |             device.device_name = name;
138 |
139 |             // Query and set device capabilities.
140 |             device.query_and_set_capabilities();
141 |
142 |             Arc::new(device)
143 |         };
144 |
145 |         let input_prop = device.query_config_prop_bits();
146 |         if let Some(prop) = input_prop {
147 |             debug!("input device prop: {:?}", prop);
148 |         } else {
149 |             debug!("input device has no properties or the properties is not defined");
150 |         }
151 |
152 |         let mut transport = device.transport.disable_irq().lock();
153 |         fn config_space_change(_: &TrapFrame) {
154 |             debug!("input device config space change");
155 |         }
156 |         transport
157 |             .register_cfg_callback(Box::new(config_space_change))
158 |             .unwrap();
159 |         transport.finish_init();
160 |         drop(transport);
161 |
162 |         // Register with the input subsystem.
163 |         let registered_device = aster_input::register_device(device.clone());
164 |
165 |         let mut transport = device.transport.disable_irq().lock();
    |                             ------------------------------ 
 Use-after-free (confidence 99%): Location in file kernel/comps/virtio/src/device/input/device.rs line 165.
    | MIR detail: Value _216 and _198 are alias.
    | MIR detail: _216 is dropped at BB85; _198 is used at BB90.
166 |         let handle_input = {
167 |             let device = device.clone();
168 |             move |_: &TrapFrame| device.handle_irq(&registered_device)
169 |         };
170 |         transport
171 |             .register_queue_callback(QUEUE_EVENT, Box::new(handle_input), false)
172 |             .unwrap();
173 |         drop(transport);
174 |
175 |         Ok(())
176 |     }
    |
warning: Use-after-free detected.
   --> kernel/comps/virtio/src/device/input/device.rs:165:29
    |
 92 | pub fn init(mut transport: Box<dyn VirtioTransport>) -> Result<(), VirtioDeviceError> {
 93 |         let mut event_queue = VirtQueue::new(QUEUE_EVENT, QUEUE_SIZE, transport.as_mut())
 94 |             .expect("create event virtqueue failed");
 95 |         let status_queue = VirtQueue::new(QUEUE_STATUS, QUEUE_SIZE, transport.as_mut())
 96 |             .expect("create status virtqueue failed");
 97 |
 98 |         let event_table = EventTable::new(QUEUE_SIZE as usize);
 99 |         for i in 0..event_table.num_events() {
100 |             let event_buf = event_table.get(i);
101 |             let token = event_queue.add_dma_buf(&[], &[&event_buf]);
102 |             match token {
103 |                 Ok(value) => {
104 |                     assert_eq!(value, i as u16);
105 |                 }
106 |                 Err(_) => {
107 |                     return Err(VirtioDeviceError::QueueUnknownError);
108 |                 }
109 |             }
110 |         }
111 |
112 |         let device = {
113 |             let mut device = Self {
114 |                 config: VirtioInputConfig::new(transport.as_mut()),
115 |                 event_queue: SpinLock::new(event_queue),
116 |                 status_queue,
117 |                 event_table,
118 |                 transport: SpinLock::new(transport),
119 |                 // Default name, will be updated with actual device name from config.
120 |                 device_name: "virtio_input".to_string(),
121 |                 // Physical path for virtio devices.
122 |                 device_phys: "virtio/input0".to_string(),
123 |                 // Unique identifier (empty for virtio devices).
124 |                 device_uniq: "".to_string(),
125 |                 // Device ID with virtio-specific values.
126 |                 // BUS_VIRTUAL (0x06): Virtual bus type
127 |                 // vendor (0x0001): Generic vendor ID for standard keyboards
128 |                 // product (0x0001): Generic product ID for standard keyboards
129 |                 // version (0x0001): Version 1.0
130 |                 device_id: InputId::new(InputId::BUS_VIRTUAL, 0x0001, 0x0001, 0x0001),
131 |                 capability: InputCapability::new(),
132 |             };
133 |
134 |             // Query and update device name from config.
135 |             let name = device.query_config_id_name();
136 |             info!("Virtio input device name: {}", name);
137 |             device.device_name = name;
138 |
139 |             // Query and set device capabilities.
140 |             device.query_and_set_capabilities();
141 |
142 |             Arc::new(device)
143 |         };
144 |
145 |         let input_prop = device.query_config_prop_bits();
146 |         if let Some(prop) = input_prop {
147 |             debug!("input device prop: {:?}", prop);
148 |         } else {
149 |             debug!("input device has no properties or the properties is not defined");
150 |         }
151 |
152 |         let mut transport = device.transport.disable_irq().lock();
153 |         fn config_space_change(_: &TrapFrame) {
154 |             debug!("input device config space change");
155 |         }
156 |         transport
157 |             .register_cfg_callback(Box::new(config_space_change))
158 |             .unwrap();
159 |         transport.finish_init();
160 |         drop(transport);
161 |
162 |         // Register with the input subsystem.
163 |         let registered_device = aster_input::register_device(device.clone());
164 |
165 |         let mut transport = device.transport.disable_irq().lock();
    |                             ---------------- 
 Use-after-free (confidence 99%): Location in file kernel/comps/virtio/src/device/input/device.rs line 165.
    | MIR detail: Value _216 and _202 are alias.
    | MIR detail: _216 is dropped at BB85; _202 is used at BB89.
166 |         let handle_input = {
167 |             let device = device.clone();
168 |             move |_: &TrapFrame| device.handle_irq(&registered_device)
169 |         };
170 |         transport
171 |             .register_queue_callback(QUEUE_EVENT, Box::new(handle_input), false)
172 |             .unwrap();
173 |         drop(transport);
174 |
175 |         Ok(())
176 |     }
    |
warning: Use-after-free detected.
   --> kernel/comps/virtio/src/device/input/device.rs:165:29
    |
 92 | pub fn init(mut transport: Box<dyn VirtioTransport>) -> Result<(), VirtioDeviceError> {
 93 |         let mut event_queue = VirtQueue::new(QUEUE_EVENT, QUEUE_SIZE, transport.as_mut())
 94 |             .expect("create event virtqueue failed");
 95 |         let status_queue = VirtQueue::new(QUEUE_STATUS, QUEUE_SIZE, transport.as_mut())
 96 |             .expect("create status virtqueue failed");
 97 |
 98 |         let event_table = EventTable::new(QUEUE_SIZE as usize);
 99 |         for i in 0..event_table.num_events() {
100 |             let event_buf = event_table.get(i);
101 |             let token = event_queue.add_dma_buf(&[], &[&event_buf]);
102 |             match token {
103 |                 Ok(value) => {
104 |                     assert_eq!(value, i as u16);
105 |                 }
106 |                 Err(_) => {
107 |                     return Err(VirtioDeviceError::QueueUnknownError);
108 |                 }
109 |             }
110 |         }
111 |
112 |         let device = {
113 |             let mut device = Self {
114 |                 config: VirtioInputConfig::new(transport.as_mut()),
115 |                 event_queue: SpinLock::new(event_queue),
116 |                 status_queue,
117 |                 event_table,
118 |                 transport: SpinLock::new(transport),
119 |                 // Default name, will be updated with actual device name from config.
120 |                 device_name: "virtio_input".to_string(),
121 |                 // Physical path for virtio devices.
122 |                 device_phys: "virtio/input0".to_string(),
123 |                 // Unique identifier (empty for virtio devices).
124 |                 device_uniq: "".to_string(),
125 |                 // Device ID with virtio-specific values.
126 |                 // BUS_VIRTUAL (0x06): Virtual bus type
127 |                 // vendor (0x0001): Generic vendor ID for standard keyboards
128 |                 // product (0x0001): Generic product ID for standard keyboards
129 |                 // version (0x0001): Version 1.0
130 |                 device_id: InputId::new(InputId::BUS_VIRTUAL, 0x0001, 0x0001, 0x0001),
131 |                 capability: InputCapability::new(),
132 |             };
133 |
134 |             // Query and update device name from config.
135 |             let name = device.query_config_id_name();
136 |             info!("Virtio input device name: {}", name);
137 |             device.device_name = name;
138 |
139 |             // Query and set device capabilities.
140 |             device.query_and_set_capabilities();
141 |
142 |             Arc::new(device)
143 |         };
144 |
145 |         let input_prop = device.query_config_prop_bits();
146 |         if let Some(prop) = input_prop {
147 |             debug!("input device prop: {:?}", prop);
148 |         } else {
149 |             debug!("input device has no properties or the properties is not defined");
150 |         }
151 |
152 |         let mut transport = device.transport.disable_irq().lock();
153 |         fn config_space_change(_: &TrapFrame) {
154 |             debug!("input device config space change");
155 |         }
156 |         transport
157 |             .register_cfg_callback(Box::new(config_space_change))
158 |             .unwrap();
159 |         transport.finish_init();
160 |         drop(transport);
161 |
162 |         // Register with the input subsystem.
163 |         let registered_device = aster_input::register_device(device.clone());
164 |
165 |         let mut transport = device.transport.disable_irq().lock();
    |                             ------------------------------------- 
 Use-after-free (confidence 99%): Location in file kernel/comps/virtio/src/device/input/device.rs line 165.
    | MIR detail: Value _216 and _222 are alias.
    | MIR detail: _216 is dropped at BB85; _222 is used at BB90.
166 |         let handle_input = {
167 |             let device = device.clone();
168 |             move |_: &TrapFrame| device.handle_irq(&registered_device)
169 |         };
170 |         transport
171 |             .register_queue_callback(QUEUE_EVENT, Box::new(handle_input), false)
172 |             .unwrap();
173 |         drop(transport);
174 |
175 |         Ok(())
176 |     }
    |
Over visited: DefId(0:1895 ~ aster_virtio[0497]::device::network::config::{impl#11}::fmt)
Over visited: DefId(0:2146 ~ aster_virtio[0497]::device::network::config::{impl#37}::fmt)
Over visited: DefId(0:428 ~ aster_virtio[0497]::device::network::device::{impl#1}::init)
Over visited: DefId(0:2271 ~ aster_virtio[0497]::device::network::header::{impl#15}::fmt)
Over visited: DefId(0:2395 ~ aster_virtio[0497]::device::socket::config::{impl#11}::fmt)
Over visited: DefId(0:2705 ~ aster_virtio[0497]::device::socket::header::{impl#31}::fmt)
Over visited: DefId(0:718 ~ aster_virtio[0497]::queue::{impl#0}::new)
Over visited: DefId(0:3147 ~ aster_virtio[0497]::queue::{impl#20}::fmt)
20:05:33|RAP|WARN|: Use-after-free detected in function "new"
warning: Use-after-free detected.
  --> kernel/comps/virtio/src/transport/mmio/multiplex.rs:73:9
   |
27 | pub fn new(
28 |         irq: IrqLine,
29 |         interrupt_ack: SafePtr<u32, IoMem, TRightSet<WriteOp>>,
30 |         interrupt_status: SafePtr<u32, IoMem, TRightSet<ReadOp>>,
31 |     ) -> Arc<RwLock<Self>> {
32 |         let irq = Arc::new(RwLock::new(Self {
33 |             irq,
34 |             queue_callbacks: Vec::new(),
35 |             cfg_callbacks: Vec::new(),
36 |             interrupt_ack,
37 |             interrupt_status,
38 |         }));
39 |
40 |         // Holding a weak reference to prevent memory leakage due to
41 |         // circular reference.
42 |         let weak = Arc::downgrade(&irq);
43 |         let callback = move |trap_frame: &TrapFrame| {
44 |             let Some(multiplex_irq) = weak.upgrade() else {
45 |                 return;
46 |             };
47 |             let irq = multiplex_irq.read();
48 |
49 |             let interrupt_status = irq.interrupt_status.read_once().unwrap();
50 |             // Acknowledging before invoking the callbacks to prevent the loss of unhandled
51 |             // interrupts due to race conditions.
52 |             irq.interrupt_ack.write_once(&interrupt_status).unwrap();
53 |
54 |             // Used buffer notification
55 |             if interrupt_status & 0x01 != 0 {
56 |                 for callback in irq.queue_callbacks.iter() {
57 |                     (callback)(trap_frame);
58 |                 }
59 |             }
60 |
61 |             // Configuration change notification
62 |             if interrupt_status & 0x02 != 0 {
63 |                 for callback in irq.cfg_callbacks.iter() {
64 |                     (callback)(trap_frame);
65 |                 }
66 |             }
67 |         };
68 |
69 |         let mut lock = irq.write();
70 |         lock.irq.on_active(callback);
71 |         drop(lock);
72 |
73 |         irq
   |         --- 
 Use-after-free (confidence 99%): Location in file kernel/comps/virtio/src/transport/mmio/multiplex.rs line 73.
    | MIR detail: Value _26 and _4 are alias.
    | MIR detail: _26 is dropped at BB9; _4 is used at BB10.
74 |     }
   |
20:05:33|RAP|WARN|: Dangling pointer detected in function "new"
warning: Dangling pointer detected.
  --> kernel/comps/virtio/src/transport/mmio/multiplex.rs:27:1
   |
27 | / pub fn new(
28 | |         irq: IrqLine,
29 | |         interrupt_ack: SafePtr<u32, IoMem, TRightSet<WriteOp>>,
30 | |         interrupt_status: SafePtr<u32, IoMem, TRightSet<ReadOp>>,
31 | |     ) -> Arc<RwLock<Self>> {
32 | |         let irq = Arc::new(RwLock::new(Self {
33 | |             irq,
34 | |             queue_callbacks: Vec::new(),
35 | |             cfg_callbacks: Vec::new(),
36 | |             interrupt_ack,
37 | |             interrupt_status,
38 | |         }));
39 | |
40 | |         // Holding a weak reference to prevent memory leakage due to
41 | |         // circular reference.
42 | |         let weak = Arc::downgrade(&irq);
43 | |         let callback = move |trap_frame: &TrapFrame| {
44 | |             let Some(multiplex_irq) = weak.upgrade() else {
45 | |                 return;
46 | |             };
47 | |             let irq = multiplex_irq.read();
48 | |
49 | |             let interrupt_status = irq.interrupt_status.read_once().unwrap();
50 | |             // Acknowledging before invoking the callbacks to prevent the loss of unhandled
51 | |             // interrupts due to race conditions.
52 | |             irq.interrupt_ack.write_once(&interrupt_status).unwrap();
53 | |
54 | |             // Used buffer notification
55 | |             if interrupt_status & 0x01 != 0 {
56 | |                 for callback in irq.queue_callbacks.iter() {
57 | |                     (callback)(trap_frame);
58 | |                 }
59 | |             }
60 | |
61 | |             // Configuration change notification
62 | |             if interrupt_status & 0x02 != 0 {
63 | |                 for callback in irq.cfg_callbacks.iter() {
64 | |                     (callback)(trap_frame);
65 | |                 }
66 | |             }
67 | |         };
68 | |
69 | |         let mut lock = irq.write();
70 | |         lock.irq.on_active(callback);
71 | |         drop(lock);
72 | |
73 | |         irq
74 | |     }
   | |_____- 
 Dangling pointer (confidence 99%): Location in file kernel/comps/virtio/src/transport/mmio/multiplex.rs line 27.
    | MIR detail: Value _26 and _0 are alias.
    | MIR detail: _26 is dropped at BB9; _0 became dangling.
   |

thread 'rustc' (76585) panicked at src/analysis/safedrop/alias.rs:218:33:
index out of bounds: the len is 166 but the index is 166
stack backtrace:
   0:     0x7360f01af703 - <std::sys::backtrace::BacktraceLock::print::DisplayBacktrace as core::fmt::Display>::fmt::ha292289670d8ccb0
   1:     0x7360f0801a98 - core::fmt::write::h9dfaa01855044d01
   2:     0x7360f0164531 - std::io::Write::write_fmt::hf248cc4a41bccb1d
   3:     0x7360f0175652 - std::sys::backtrace::BacktraceLock::print::hd8c2244c375c35ab
   4:     0x7360f017b599 - std::panicking::default_hook::{{closure}}::h20a380f5fd0a0eef
   5:     0x7360f017b0c3 - std::panicking::default_hook::h5fff69ce0d714047
   6:     0x7360ef1c2f37 - std[989bc2be79487f22]::panicking::update_hook::<alloc[add7e349b679f9ea]::boxed::Box<rustc_driver_impl[5fb32e0a6e7437c8]::install_ice_hook::{closure#1}>>::{closure#0}
   7:     0x7360f017b9bf - std::panicking::panic_with_hook::h3472d77cd4b8d7f5
   8:     0x7360f017b77a - std::panicking::panic_handler::{{closure}}::hd249e00cedf2bb65
   9:     0x7360f0175789 - std::sys::backtrace::__rust_end_short_backtrace::h38f3b7f00889b7f3
  10:     0x7360f0155f6d - __rustc[3a56062fa64d4fc0]::rust_begin_unwind
  11:     0x7360ec8c2fb0 - core::panicking::panic_fmt::h38794a43703d8bee
  12:     0x7360ee902a83 - core::panicking::panic_bounds_check::h3a8cdeb727ce9ec3
  13:     0x62c87244baa5 - rapx::analysis::safedrop::alias::<impl rapx::analysis::safedrop::graph::SafeDropGraph>::merge_alias::h7b27885fbb6d4655
  14:     0x62c87244c446 - rapx::analysis::safedrop::alias::<impl rapx::analysis::safedrop::graph::SafeDropGraph>::alias_bbcall::hf5bb425694f08c46
  15:     0x62c872454e9d - rapx::analysis::safedrop::safedrop::<impl rapx::analysis::safedrop::graph::SafeDropGraph>::check::h870471ff6627fc00
  16:     0x62c872458c4f - rapx::analysis::safedrop::safedrop::<impl rapx::analysis::safedrop::graph::SafeDropGraph>::check::h870471ff6627fc00
  17:     0x62c87245674d - rapx::analysis::safedrop::safedrop::<impl rapx::analysis::safedrop::graph::SafeDropGraph>::check::h870471ff6627fc00
  18:     0x62c872458c4f - rapx::analysis::safedrop::safedrop::<impl rapx::analysis::safedrop::graph::SafeDropGraph>::check::h870471ff6627fc00
  19:     0x62c872458c4f - rapx::analysis::safedrop::safedrop::<impl rapx::analysis::safedrop::graph::SafeDropGraph>::check::h870471ff6627fc00
  20:     0x62c872458c4f - rapx::analysis::safedrop::safedrop::<impl rapx::analysis::safedrop::graph::SafeDropGraph>::check::h870471ff6627fc00
  21:     0x62c872458c4f - rapx::analysis::safedrop::safedrop::<impl rapx::analysis::safedrop::graph::SafeDropGraph>::check::h870471ff6627fc00
  22:     0x62c872458c4f - rapx::analysis::safedrop::safedrop::<impl rapx::analysis::safedrop::graph::SafeDropGraph>::check::h870471ff6627fc00
  23:     0x62c872458c4f - rapx::analysis::safedrop::safedrop::<impl rapx::analysis::safedrop::graph::SafeDropGraph>::check::h870471ff6627fc00
  24:     0x62c872458c4f - rapx::analysis::safedrop::safedrop::<impl rapx::analysis::safedrop::graph::SafeDropGraph>::check::h870471ff6627fc00
  25:     0x62c872454bec - rapx::analysis::safedrop::safedrop::<impl rapx::analysis::safedrop::graph::SafeDropGraph>::split_check_with_cond::h79a5b7e93dc001a4
  26:     0x62c872457ee0 - rapx::analysis::safedrop::safedrop::<impl rapx::analysis::safedrop::graph::SafeDropGraph>::check::h870471ff6627fc00
  27:     0x62c872458c4f - rapx::analysis::safedrop::safedrop::<impl rapx::analysis::safedrop::graph::SafeDropGraph>::check::h870471ff6627fc00
  28:     0x62c872458c4f - rapx::analysis::safedrop::safedrop::<impl rapx::analysis::safedrop::graph::SafeDropGraph>::check::h870471ff6627fc00
  29:     0x62c87245320c - rapx::analysis::safedrop::safedrop::<impl rapx::analysis::safedrop::graph::SafeDropGraph>::split_check::hb3061cf45db49b4a
  30:     0x62c8724580a5 - rapx::analysis::safedrop::safedrop::<impl rapx::analysis::safedrop::graph::SafeDropGraph>::check::h870471ff6627fc00
  31:     0x62c872458c4f - rapx::analysis::safedrop::safedrop::<impl rapx::analysis::safedrop::graph::SafeDropGraph>::check::h870471ff6627fc00
  32:     0x62c872403b13 - rapx::analysis::safedrop::query_safedrop::h64cade6d01fc636c
  33:     0x62c872403dfe - rapx::analysis::safedrop::SafeDrop::start::hd33f89aa3d62e2bc
  34:     0x62c8725124e6 - rapx::start_analyzer::h656aa87965bd1d35
  35:     0x62c87252fb27 - scoped_tls::ScopedKey<T>::set::h03c569472945a318
  36:     0x62c87252fda5 - scoped_tls::ScopedKey<T>::set::h0cbfe0aba6d2dcc8
  37:     0x62c8723d114f - rustc_public::rustc_internal::run::h1b7694366d3e9a8c
  38:     0x62c87252c448 - <rapx::RapCallback as rustc_driver_impl::Callbacks>::after_analysis::h907e6d18ff80e183
  39:     0x7360f1b3a73f - rustc_interface[b1ae535157b9343d]::passes::create_and_enter_global_ctxt::<core[6c151eb9844fe7ce]::option::Option<rustc_interface[b1ae535157b9343d]::queries::Linker>, rustc_driver_impl[5fb32e0a6e7437c8]::run_compiler::{closure#0}::{closure#2}>::{closure#2}::{closure#0}
  40:     0x7360f1adc37e - rustc_interface[b1ae535157b9343d]::interface::run_compiler::<(), rustc_driver_impl[5fb32e0a6e7437c8]::run_compiler::{closure#0}>::{closure#1}
  41:     0x7360f1a1b3b8 - std[989bc2be79487f22]::sys::backtrace::__rust_begin_short_backtrace::<rustc_interface[b1ae535157b9343d]::util::run_in_thread_with_globals<rustc_interface[b1ae535157b9343d]::util::run_in_thread_pool_with_globals<rustc_interface[b1ae535157b9343d]::interface::run_compiler<(), rustc_driver_impl[5fb32e0a6e7437c8]::run_compiler::{closure#0}>::{closure#1}, ()>::{closure#0}, ()>::{closure#0}::{closure#0}, ()>
  42:     0x7360f1a1b088 - <<std[989bc2be79487f22]::thread::Builder>::spawn_unchecked_<rustc_interface[b1ae535157b9343d]::util::run_in_thread_with_globals<rustc_interface[b1ae535157b9343d]::util::run_in_thread_pool_with_globals<rustc_interface[b1ae535157b9343d]::interface::run_compiler<(), rustc_driver_impl[5fb32e0a6e7437c8]::run_compiler::{closure#0}>::{closure#1}, ()>::{closure#0}, ()>::{closure#0}::{closure#0}, ()>::{closure#1} as core[6c151eb9844fe7ce]::ops::function::FnOnce<()>>::call_once::{shim:vtable#0}
  43:     0x7360f1a2134d - std::sys::pal::unix::thread::Thread::new::thread_start::h0a9b1b8aa28834ae
  44:     0x7360ea29caa4 - start_thread
                               at ./nptl/pthread_create.c:447:8
  45:     0x7360ea329c6c - clone3
                               at ./misc/../sysdeps/unix/sysv/linux/x86_64/clone3.S:78:0
  46:                0x0 - <unknown>

error: the compiler unexpectedly panicked. this is a bug.

note: we would appreciate a bug report: bug_report_url

note: please make sure that you have updated to the latest nightly

note: please attach the file at `/home/zjp/asterinas/rustc-ice-2025-12-09T12_04_26-76584.txt` to your bug report

note: compiler flags: --crate-type lib -C embed-bitcode=no -C debuginfo=2 -C incremental=[REDACTED] -C link-arg=-fuse-ld=mold

note: some of the compiler flags provided by cargo are hidden

query stack during panic:
end of query stack
error: could not compile `aster-virtio` (lib)

Caused by:
  process didn't exit successfully: `/home/zjp/.cargo/bin/cargo-rapx /home/zjp/.rustup/toolchains/nightly-2025-09-10-x86_64-unknown-linux-gnu/bin/rustc --crate-name aster_virtio --edition=2024 kernel/comps/virtio/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata -C embed-bitcode=no -C debuginfo=2 --warn=unsafe_op_in_unsafe_fn --allow=unexpected_cfgs '--warn=clippy::allow_attributes' --check-cfg 'cfg(ktest)' --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values("all", "cvm_guest"))' -C metadata=abf42a95eb38aa79 -C extra-filename=-8b506966cfb5ce48 --out-dir /home/zjp/asterinas/target/x86_64-unknown-none/debug/deps --target x86_64-unknown-none -C incremental=/home/zjp/asterinas/target/x86_64-unknown-none/debug/incremental -L dependency=/home/zjp/asterinas/target/x86_64-unknown-none/debug/deps -L dependency=/home/zjp/asterinas/target/debug/deps --extern aster_bigtcp=/home/zjp/asterinas/target/x86_64-unknown-none/debug/deps/libaster_bigtcp-1bd4b490fca3fc29.rmeta --extern aster_block=/home/zjp/asterinas/target/x86_64-unknown-none/debug/deps/libaster_block-b0f7aeb28e7c5c97.rmeta --extern aster_console=/home/zjp/asterinas/target/x86_64-unknown-none/debug/deps/libaster_console-d2936b976ad5bcfa.rmeta --extern aster_input=/home/zjp/asterinas/target/x86_64-unknown-none/debug/deps/libaster_input-ce7f4aa03622ff7e.rmeta --extern aster_network=/home/zjp/asterinas/target/x86_64-unknown-none/debug/deps/libaster_network-eb88833e49b6eaa6.rmeta --extern aster_pci=/home/zjp/asterinas/target/x86_64-unknown-none/debug/deps/libaster_pci-324589e1effc47b1.rmeta --extern aster_rights=/home/zjp/asterinas/target/x86_64-unknown-none/debug/deps/libaster_rights-03b688b975692259.rmeta --extern aster_softirq=/home/zjp/asterinas/target/x86_64-unknown-none/debug/deps/libaster_softirq-287ece825d88b134.rmeta --extern aster_systree=/home/zjp/asterinas/target/x86_64-unknown-none/debug/deps/libaster_systree-2e134f99066a1a63.rmeta --extern aster_util=/home/zjp/asterinas/target/x86_64-unknown-none/debug/deps/libaster_util-4311d230d53845c3.rmeta --extern bitflags=/home/zjp/asterinas/target/x86_64-unknown-none/debug/deps/libbitflags-c836927ee9a6a8de.rmeta --extern component=/home/zjp/asterinas/target/x86_64-unknown-none/debug/deps/libcomponent-cb5f505afbf7aa38.rmeta --extern device_id=/home/zjp/asterinas/target/x86_64-unknown-none/debug/deps/libdevice_id-bd4a339d4d8e341e.rmeta --extern id_alloc=/home/zjp/asterinas/target/x86_64-unknown-none/debug/deps/libid_alloc-8d8b05fdd0836af0.rmeta --extern int_to_c_enum=/home/zjp/asterinas/target/x86_64-unknown-none/debug/deps/libint_to_c_enum-e924f658c0712ee3.rmeta --extern log=/home/zjp/asterinas/target/x86_64-unknown-none/debug/deps/liblog-9a39a60720065c7e.rmeta --extern ostd=/home/zjp/asterinas/target/x86_64-unknown-none/debug/deps/libostd-b73e54a995219854.rmeta --extern spin=/home/zjp/asterinas/target/x86_64-unknown-none/debug/deps/libspin-1a69b0285fae72ac.rmeta --extern typeflags_util=/home/zjp/asterinas/target/x86_64-unknown-none/debug/deps/libtypeflags_util-db818b664b97b393.rmeta -Clink-arg=-fuse-ld=mold` (exit status: 101)
warning: build failed, waiting for other jobs to finish...
